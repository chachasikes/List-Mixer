<?php
// $Id$

/******************************************************************************
 * @file
 * Main module file for Drag List module
 *
 * This is a relatively simple module that will be used for the 
 * Test Writing workshop. 
 *
 * While the module is relatively simple, there are lots of places where
 * it could break. 
 
 
 
 * Set up
 1. Install and enable the Drag List module.
 2. Enable permissions for Drag List module.
 3. Enable drag_list_select view (Enable this one first, because it is
    required by the content type.)
 4. Tweak the drag_list_select view to use content types available on your system.
 5. Install and enable the Drag List content type (drag_list) 
 6. Finally, enable the drag_list_blocks view.
 7. Visit the blocks page, enable the 'drag_list_blocks: Drag List' block. 
    You will probably want this block on all pages.
 8. Make sure there is some content on your site. (drag-list/content should
    show you a list of nodes that would work.)
 7. Adjust settings: admin/settings/drag_list. You can rename the fields 
    that are allowed with the functions in this module. This moduel currently
    supports one nodereference field and one link field.
 
 
 
 * How the module works:
   Javascript is added to pages. This javascript interacts with a certain block.
   An 'activate' link it created under the block. When users click 'Activate'
   all of the links on the page are highlighted.
   Clicking links triggers an ajax function.
   The ajax function takes the node id of the node that being shown in the view
   block (which has been set specific to the user.) 
   The javascript sents POST data to the callback $_POST['drag_list_value']
   The callback function reads the post data and the target node id.
   The post data contains the path of the link that was clicked. The callback
   parses the link. If it is an absolute URL, it is stored in the link. 
   If it is a relative URL (which means it is probably a Drupal system path)
   then the function checks if the path is for a node. If there is a node id
   then that value will be set via node_save. 
   
* Still to do
  1. The javascript shouldn't be added to every page, only pages with the block.
  2. Block refresh - currently you need to refresh the page to make the 
     block update
  3. rename module and views... drag_list is sort of a misnomer now. 
  4. Write out help.
  5. Document all functions. 
  6. The storage callback should become somethink like an api function.
 
 * Possible tests:
   1. What happens if the field name is changed?
   2. What happens if the block id is changed?
   3. What happens if a user does not have permissions to save to the target node?
   4. What happens if bad data is passed to the callback?
   5. Create a way to test the $_POST data that would get passed into the callback.
   6. What happens if the user installs the modules in the wrong way, or not completely?
   7. Are the permissions working properly?
   
   
   Javascript unit testing? http://drupal.org/node/237566
   

 * Tests to not worry about
   1. Do not worry about testing the javascript itself.    
   
 * 
 */

/**
 * Implementation of hook_help().
 */
function drag_list_help($section) {
  switch ($section) {
    case 'admin/help#drag_list':
  return '<p>'. t('The Drag List module allows users to store links to a list.') .'</p>';
      
  }
}

/**
 * Implementation of hook_perm().
 */
function drag_list_perm() {
  return array('administer drag list', 'access drag list');
}

/**
 * Implementation of hook_menu().
 */
function drag_list_menu() { 
  $items = array();
  // Code extract configuration pages
  $items['admin/settings/drag_list'] = array(
    'title' => 'Drag List Settings',
    'description' => 'Configure Drag List',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('drag_list_admin_settings'),
    'access arguments' => array('administer drag list'),
    'file' => 'includes/drag_list.admin.inc',
  );
  $items['admin/drag-list/ajax/store/%'] = array(
    'title' => 'Load Drag List form',
    'description' => 'loading form callback',
    'page callback' => 'drag_list_ajax_store',
    'page arguments' => array(4),
    'access arguments' => array('access drag list'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}
/**
 * Drag List, init 
 *
 */
function drag_list_init() {
  // Add the javascript.
  $path = drupal_get_path('module', 'drag_list');
  // Set Drupal javascript value to the block ID stored in settings.
  drupal_add_js( array(
    'drag_list' => array(
      'dragListBlockId' => variable_get('drag_list_allowed_block', 'block-views-drag_list_blocks-block_1'), 
      ),
    ),
   'setting');
  // Add main javascript file.
  drupal_add_js($path .'/drag_list.js');
  // Add custom style sheet.
  drupal_add_css($path .'/drag_list.css');
}

/**
 * Drag List, store values from paths.
 * 
 * $target_nid The node id of the node which is being used as a list.
 */
function drag_list_ajax_store($target_nid = NULL) {
 // The value is set in the javascript.
 $link_value = $_POST['drag_list_value'];
 $is_relative_link = strpos($link_value, '/');
 $is_absolute_link = strpos($link_value, 'http://');
 $is_local_link = strpos($link_value, base_path());

 // If a link is a relative link to something in the drupal system, strip off the drupal path and replace it with absolute path.
 if (empty($is_absolute_link)) {
  if ($is_local_link == 0) {
     // Remove drupal path from the link
     $link_value = str_replace(base_path(), '', $link_value);
    // Get the node id by looking up the path alias.
    // This will try to store the node id in the node reference field. That field has user determined validators, so only certain links will be stored. 
    $path = drupal_get_normal_path($link_value);
    // If the path points to a node, get the nid value
    if (strpos($path, 'node/') >= 0) {
      $nid = str_replace('node/', '', $path);
      // Store the nodereference value in the nodereference field.
      drag_list_ajax_store_value_nodereference($target_nid, $nid, variable_get('drag_list_allowed_link_internal', 'field_link_internal'));
    }
    
  }
 }
 else{
   // Store an absolute link as a link
   drag_list_ajax_store_value_link($target_nid, $link_value, variable_get('drag_list_allowed_link_external', 'field_link_external')); 
 }
return 'Drag List value stored.';
}

function drag_list_ajax_store_value_nodereference($target_nid, $link_value, $field) {
  if (isset($target_nid) && isset($link_value)) {
    $node = node_load($target_nid);
    // See if the value has already been set for the field.
    foreach ($node->{$field} as $key => $value) {
      $nid_exists = FALSE;
      // TODO: require link/nodereference modules
      if ($node->{$field}[$key]['nid'] == $link_value) {
        $nid_exists = TRUE;
        break; 
      }     
    }
    if (!$nid_exists) {
      // Add value to beginning of the array.
       array_unshift($node->{$field}, array( 'nid' => $link_value ));
       node_save($node);
       return 'Node saved.';
    }
    else{
      return 'Node not saved because value already exists.';
    }
  }
  else{
    return 'Nodereference value not stored due to an error.';
  }
}
function drag_list_ajax_store_value_link($target_nid, $link_value, $field) {
  if (isset($target_nid) && isset($link_value)) {
    $node = node_load($target_nid);
    // See if the value has already been set for the field.
    foreach ($node->{$field} as $key => $value) {
      $nid_exists = FALSE;
      if ($node->{$field}[$key]['url'] == $link_value) {
        $nid_exists = TRUE;
        break; 
      }     
    }
    if (!$nid_exists) {
      // Add value to beginning of the array.
       array_unshift($node->{$field}, array(
        'url' => $link_value, 
        'title' => '', 
        'attributes' => array(
          'target' => '',
          'class' => '',
          'rel' => '',
        ),
        ));
        node_save($node);
        return 'Node saved.';
    }
    // TODO: What happens if invalid code is passed into the node?
    else{
      return 'Node not saved because value already exists.';
    }
  }
  else{
    return 'Nodereference value not stored due to an error.';
  }
}
// Theming functions
/**
 * Implementation of hook_theme().
 */
function drag_list_theme() {
  return array(
    'drag_list' => array('arguments' => array()),
  );
}

/**
 * Code Extract theme function.
 */
function theme_drag_list() {
 
}