// $Id$

var pageLoaded = 0;

Drupal.behaviors.listmixer = function() {
  if(pageLoaded == 0){
    // Read through each preset and set up the first time the page is loaded.
    $.each(Drupal.settings.listmixer, function(){
      // If interaction involves saving content to target nodes.
      if(this.preset_method == 'listmixer_storage_nodes') {
           
        // Node target finding mechanism #1, The First
        // The view must contain .views-field-nid (generated by adding a field)
        // @TODO add a setting so user can specify the class/field that contains the node data. then they can put it whereever. let it be a full jQuery command.

        
        // @TODO: Look up with behaviors to apply to the page
        // @TODO: Look up which behaviors to load/apply to the target
        // @TODO: So the idea will be to build a library of buttons and things, and then load them based on the behavior settings.    

        
        // Call interact function, which will interpret which markup should be created.
        // Then javascript functions to apply the interact markup to the page will run.
        // Right now, this just appends the interaction to the form (ex, an input field)
        // But if the interaction type was checkboxes, then the markup would be applied
        // to the content source (input). So, for example, if we were allowing links
        // on a page to become clickable, it would apply the interaction to the whole page.
        // Still thinking out the details.   
        
        
        
        
        // *********** Set up behaviors.
        
        // Clear data on all page loads

        Drupal.behaviors.listmixer.interact(this);
        Drupal.behaviors.listmixer.activate(this);     
        Drupal.behaviors.listmixer.submit(this);

        
        // Add callbacks
        
        
        // ************ Variables Set by user (could have errors
        // Get target node id    

        // Make sure that a container is found. 
        // This should be done first, as nothing else will happen if there is no container on the page.
        var interactions_container = $.find(this.interactions.interactions_container);
       
        // @TODO If the interactions container isn't found, that would be a good thing, but it's hard to debug
        // It's the most important part though...
        
        // Interaction container not found, do nothing, other wise, proceed.
        if(interactions_container == ''){
          return false;
        }

        var interactions_help = this.interactions.interactions_help;
        // Append help text to interaction container.
        $(interactions_container).append(interactions_help).wrap('<div></div>');

        var target_field = this.interactions.interactions_target_field;
        // @TODO Add validation function

        // Make sure that the target id is a number  
        try {    
           var target_id = $(this.interactions.interactions_target_id).html();
           target_id.length > 0;
           $(this.interactions.interactions_target_id).hide();
        }
        catch(err) {
          // @TODO console.log?
          alert('ListMixer Error: Target ID not a number or could not be found. Edit preset: admin/build/listmixer/' + this.preset_id + '');
        }
        
        // Set up target restrictions. Make sure it contains markup.  
        // Set to a default of html (the whole page)      
        if(this.interactions.interactions_restrictions === undefined) {
            this.interactions.interactions_restrictions = 'body';
        }
        var interactions_restrictions = $(this.interactions.interactions_restrictions).html();
        try {    
           interactions_restrictions.length > 0;     
        }
        catch(err) {
          alert('ListMixer Error: Restrictions Edit preset: admin/build/listmixer/' + this.preset_id + '');
        }
        
        // Set up target inclusions. If they are empty, then ignore them.
        // If they are entered, Make sure it contains markup.        
        // This one shouldn't be as strict, because whatever is being
        // looked for might not always be there.
        var ignore_inclusions = false;
        if(this.interactions.interactions_inclusions === undefined) {
            ignore_inclusions = true;
        }
        else{
          // @TODO Test this with a good example
          var interactions_inclusions = $(this.interactions.interactions_inclusions).html();
          if(ignore_inclusions != true) { 
            /*
            @TODO Fix, the boolean values are buggy
            try {   
              interactions_inclusions.length > 0;        
            }
            catch(err) {
              alert('ListMixer Error: Inclusions Edit preset: admin/build/listmixer/' + this.preset_id + '');
            }*/
          }
        }      

       
        // Create interaction form
        this.target_form_class = 'class="listmixer-target-form"';   
        this.target_form_id = 'listmixer-target-'+ this.preset_name;
        this.target_form = '<form id="' + this.target_form_id + '" ' + this.target_form_class + '></form>';
        // this.target_form = '<div ' + this.target_form_class + '>DIV</div>';
  
        var form = this.target_form;
        var container = this.interactions.interactions_container;
        // @TODO set up push saving function       
        // @TODO make default mousedown function to activate on click (add/build the form)
        // cause right now it always adds the form, and i don't think it should.
        
        // This is restrictions here. If the user just wants a form field in block,
        // Then they need to set it to just the block. Default is 'body' so 
        // if nothing is entered, it will show up at the very bottom of the page.
        
        if(this.interactions.interactions_container == this.interactions.interactions_restrictions){
          $(this.interactions.interactions_restrictions).append(this.target_form);
        }
        else{
            // Only one form is allowed, if the form should be applied to the restrictions container, but not
            // the container if the container is a child of the restrictions container.
            try{
              var form_container = this.interactions.interactions_restrictions + ':has(' + this.interactions.interactions_container + ')';
              $(form_container).length > 0;
              $(form_container).append(form);
            }
            catch(err){
              alert('ListMixer Error: Restrictions and Container conflict: admin/build/listmixer/' + this.preset_id + '');
            }
        }
        
        
        // Here is where we call various behavior functions: Interact.textInteract etc. 
        // @TODO Move to interaction behaviors
        this.interact = '<div class="listmixer-interact-input"><input></input></div>';
        
        // @TODO Move to submit behaviors
        this.submit = '<div class="listmixer-push-submit"><button class="button">Save</button></div>'; 

        
        $('form#' + this.target_form_id).append(this.interact);
        
        // Add interact button (load js from interact button function)
        $('form#' + this.target_form_id).append(this.submit);
  
        // Find the button (which might not be a button) and add a click function to it.
        var preset = this;
        
        // Set up data object on page load.
        this.data = {
          'input' : '',
          'target_id' : target_id,
          'target_field' : target_field
          // @TODO Collect other data here if necessary
        };
        
        $('form#' + this.target_form_id + ' div.listmixer-push-submit').children(".button").click(function(){
          Drupal.behaviors.listmixer.push(preset); 
        
          //@TODO make sure target_id is available to push function
          // If page stayed loaded, clear out the data array
          preset.data = {};
          $('form.listmixer-target-form div.listmixer-interact-input input').val('');
          
          return false;
        });
   
        // @TODO: connect submit function to push callback and data
        
        // @TODO: add field spec to settings for behaviors
        
        
        
        // options:
        // if view content contains 'nid'...
        // http://11heavens.com/theming-Drupal-6-from-the-module-layer
        
        // semantic view
        // make user add markup with node id -- this ensure they have ultimate control * (definite option)
        // theme preprocess function all nodes add class listmixer-node-#nid
        return false;
      }
    });
  }

  pageLoaded++;
  // Every time a page is reloaded...
}
 
// Build functions that load the behaviors.
// Load javascript behavior libraries.
Drupal.behaviors.listmixer.interact = function(preset) {    
  Drupal.behaviors.listmixer.behaviorBuildCallback(preset, 'interact');
  var Interact = new Drupal.behaviors.listmixer.Interact();
  Interact.init();        
}

Drupal.behaviors.listmixer.activate = function(preset) {    
  Drupal.behaviors.listmixer.behaviorBuildCallback(preset, 'activate');
  var Activate = new Drupal.behaviors.listmixer.Activate();
  Activate.init();         
}

Drupal.behaviors.listmixer.submit = function(preset) {    
  Drupal.behaviors.listmixer.behaviorBuildCallback(preset, 'submit');
  var Submit = new Drupal.behaviors.listmixer.Submit();
  Submit.init();
      
}
// Only called when user interacts with submit button
Drupal.behaviors.listmixer.push = function(preset) {    
  // alert('Push function called');
  // get value from interact element // @TODO value should be determined in Interact function 
  var input_value = $('form.listmixer-target-form div.listmixer-interact-input input').val();
  // Store values in data object in preset.
  preset.data.input = input_value;
           
  Drupal.behaviors.listmixer.behaviorBuildCallback(preset, 'push'); 
  var Push = new Drupal.behaviors.listmixer.Push();
  Push.init(); 
  // @TODO Check that the callback isn't reloading the page. 
  return false;  
}

// Connect behaviors

// on load: set up everything needed
// on activate, allow interact
// on interact, allow submit
// on submit, do push
// on push feedback, update markup

//if activate is set to none, allow interact
//if interact is set to none, ?? then what?
//if submit is set to none, ?? there needs to be some sort of default
// if push is set to none, ?? 

// rules
// there is always an activate button. it is off by default always.
// make a type of activate which is 'onmouseclick' of whatever the interact button is
// otherwise, allow for an actual button to be set.

// interact - there is always something. the default will be tied to the push type?
// interact ties an interaction method to a push type. so, given a class of something, it reads it and scrapes the data to prep it for push

// push - there's no use to having push except for testing.
// push takes data from interact and stores it in the right format
// to store a nid - you could select it ('123') you could add checkboxes next to all available nids on a page, you could enter the number, you could click a link

// in the settings for the preset - make fields that will contain the jquery that will say where everything should go

// for example: 

/**
 * Order of execution
 * 
 * The page loads.
 * For each preset, behavior libraries are loaded.
 * Using a callback for each preset behavior, load and render markup (buildCallback)
 * When an action is taken, send data to be processed, and return new markup (submitCallback)
 *
 */

// Load javascript includes, set up the callbacks for all behaviors.
Drupal.behaviors.listmixer.behaviorBuildCallback = function(preset, type) {
  var preset = preset;
  var type = type;
  var preset_id = preset.preset_id;
  var callback;
  var behavior_name;
  var behavior_function;
  // Create an array of the settings for the current behavior.
  //alert(preset.data.input);
  var behavior = preset.behaviors[type];
  if(behavior.settings != null){
    callback = behavior.settings.behavior_callback;
    behavior_function = behavior.settings.behavior_function;
    behavior_name =  behavior.settings.behavior_name;

    // Load data from settings array contained in each behavior.
    // @TODO a callback is called. a menu item figures out who the callback is for, looks up the registry and calls the appropriate function.
    // Grab data from somewhere that's stored somewhere else.
    // The data might need to be cleaned up if the funciton is used several times before submitting  


    // Ajax call to callback for this behavior.
    // @TODO currently this runs automatically, make push happen after submit behavior is activated.
    if(callback != null) {
      $.post(callback, preset.data, Drupal.behaviors.listmixer.redirect(preset, preset.data));
      return false;
    }
  }
  return false;
}
// Load javascript includes, set up the callbacks for all behaviors.
Drupal.behaviors.listmixer.behaviorSubmitCallback = function(preset, type) {
  var preset = preset;
  var type = type;
  var preset_id = preset.preset_id;
  var callback;
  var behavior_name;
  var behavior_function;
  // Create an array of the settings for the current behavior.
  var behavior = preset.behaviors[type];
  if(behavior.settings != null){
    // @TODO rename _redirect to _submit_callback, and _callback to _build_callback
    callback = behavior.settings.behavior_redirect;


    behavior_name =  behavior.settings.behavior_name;

    // Load data from settings array contained in each behavior.
    // @TODO a callback is called. a menu item figures out who the callback is for, looks up the registry and calls the appropriate function.
    // Grab data from somewhere that's stored somewhere else.
    // The data might need to be cleaned up if the funciton is used several times before submitting  
    //var data_label = 'data_' + behavior_name;
    //$(this).attr('drag_list_value')
    var data = {data_label : 'test data content'};

       
    // Ajax call to callback for this behavior.
    // @TODO currently this runs automatically, make push happen after submit behavior is activated.
    if(callback != null) {
      $.post(callback, data, Drupal.behaviors.listmixer.redirect(preset, preset.data));
    }
  }
  return false; 
}    
Drupal.behaviors.listmixer.Behavior = function(){ 
  // Create new object stored in include file.
  var Behavior = new Behavior();
  //Behavior.init();
  //return Behavior;
  return false;
}

Drupal.behaviors.listmixer.redirect = function(preset, data) {
  var preset = preset;
  var data = data;  
  
  // Get the returned javascript from the function and apply it wherever it is supposed to go
  // @TODO: maybe - Calling the redirect function, which returns $output?

  return false;  
}
